"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `Match`."""
  matches(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Match`."""
    orderBy: [MatchesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MatchCondition
  ): MatchesConnection

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition
  ): UsersConnection
  match(id: Int!): Match
  user(id: Int!): User

  """Get the current user."""
  currentUser: User

  """Reads a single `Match` using its globally unique `ID`."""
  matchByNodeId(
    """The globally unique `ID` to be used in selecting a single `Match`."""
    nodeId: ID!
  ): Match

  """Reads a single `User` using its globally unique `ID`."""
  userByNodeId(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `Match` values."""
type MatchesConnection {
  """A list of `Match` objects."""
  nodes: [Match!]!

  """
  A list of edges which contains the `Match` and cursor to aid in pagination.
  """
  edges: [MatchesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Match` you could get from the connection."""
  totalCount: Int!
}

"""A single beach volley match."""
type Match implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Unique id of the match."""
  id: Int!

  """Location where the match is held."""
  location: String

  """Start and end time of the match."""
  time: DatetimeRange

  """Minimun and maximun number of players in the match."""
  playerLimit: IntRange

  """Is the match public or private. Default is private."""
  public: Boolean!

  """List of participant names who have joined the match."""
  participants: [String]!

  """Host and creator of the match."""
  hostId: Int!

  """Is the match men only, women only, or mixed. Default is mixed."""
  matchType: MatchType!

  """Required player skill level for the match. Default is EASY_HARD."""
  requiredSkillLevel: SkillLevel!

  """Optional description of the match."""
  description: String

  """Reads a single `User` that is related to this `Match`."""
  host: User
}

"""A range of `Datetime`."""
type DatetimeRange {
  """The starting bound of our range."""
  start: DatetimeRangeBound

  """The ending bound of our range."""
  end: DatetimeRangeBound
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
type DatetimeRangeBound {
  """The value at one end of our range."""
  value: Datetime!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""A range of `Int`."""
type IntRange {
  """The starting bound of our range."""
  start: IntRangeBound

  """The ending bound of our range."""
  end: IntRangeBound
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
type IntRangeBound {
  """The value at one end of our range."""
  value: Int!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""Match type (men, women, or mixed)."""
enum MatchType {
  MEN
  WOMEN
  MIXED
}

"""Skill level (easy, medium, hard, or a combination of them)."""
enum SkillLevel {
  EASY
  MEDIUM
  HARD

  """EASY or MEDIUM"""
  EASY_MEDIUM

  """MEDIUM or HARD"""
  MEDIUM_HARD

  """EASY or MEDIUM or HARD"""
  EASY_HARD
}

"""A user of the app."""
type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Unique id of the user."""
  id: Int!

  """Display name of the user."""
  name: String!

  """Reads and enables pagination through a set of `Match`."""
  matchesByHostId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Match`."""
    orderBy: [MatchesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MatchCondition
  ): MatchesConnection!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Methods to use when ordering `Match`."""
enum MatchesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  HOST_ID_ASC
  HOST_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Match` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input MatchCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `hostId` field."""
  hostId: Int
}

"""A `Match` edge in the connection."""
type MatchesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Match` at the end of the edge."""
  node: Match!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User!]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  UID_ASC
  UID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `uid` field."""
  uid: String
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `Match`."""
  createMatch(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMatchInput!
  ): CreateMatchPayload

  """Updates a single `Match` using its globally unique id and a patch."""
  updateMatchByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMatchByNodeIdInput!
  ): UpdateMatchPayload

  """Updates a single `Match` using a unique key and a patch."""
  updateMatch(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMatchInput!
  ): UpdateMatchPayload

  """Deletes a single `Match` using its globally unique id."""
  deleteMatchByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMatchByNodeIdInput!
  ): DeleteMatchPayload

  """Deletes a single `Match` using a unique key."""
  deleteMatch(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMatchInput!
  ): DeleteMatchPayload

  """Create user or update it's details based on JWT."""
  upsertUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpsertUserInput!
  ): UpsertUserPayload
}

"""The output of our create `Match` mutation."""
type CreateMatchPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Match` that was created by this mutation."""
  match: Match

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Match`."""
  host: User

  """An edge for our `Match`. May be used by Relay 1."""
  matchEdge(
    """The method to use when ordering `Match`."""
    orderBy: [MatchesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MatchesEdge
}

"""All input for the create `Match` mutation."""
input CreateMatchInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Match` to be created by this mutation."""
  match: MatchInput!
}

"""An input for mutations affecting `Match`"""
input MatchInput {
  """Location where the match is held."""
  location: String

  """Start and end time of the match."""
  time: DatetimeRangeInput

  """Minimun and maximun number of players in the match."""
  playerLimit: IntRangeInput

  """Is the match public or private. Default is private."""
  public: Boolean

  """List of participant names who have joined the match."""
  participants: [String]

  """Host and creator of the match."""
  hostId: Int

  """Is the match men only, women only, or mixed. Default is mixed."""
  matchType: MatchType

  """Required player skill level for the match. Default is EASY_HARD."""
  requiredSkillLevel: SkillLevel

  """Optional description of the match."""
  description: String
}

"""A range of `Datetime`."""
input DatetimeRangeInput {
  """The starting bound of our range."""
  start: DatetimeRangeBoundInput

  """The ending bound of our range."""
  end: DatetimeRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input DatetimeRangeBoundInput {
  """The value at one end of our range."""
  value: Datetime!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""A range of `Int`."""
input IntRangeInput {
  """The starting bound of our range."""
  start: IntRangeBoundInput

  """The ending bound of our range."""
  end: IntRangeBoundInput
}

"""
The value at one end of a range. A range can either include this value, or not.
"""
input IntRangeBoundInput {
  """The value at one end of our range."""
  value: Int!

  """Whether or not the value of this bound is included in the range."""
  inclusive: Boolean!
}

"""The output of our update `Match` mutation."""
type UpdateMatchPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Match` that was updated by this mutation."""
  match: Match

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Match`."""
  host: User

  """An edge for our `Match`. May be used by Relay 1."""
  matchEdge(
    """The method to use when ordering `Match`."""
    orderBy: [MatchesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MatchesEdge
}

"""All input for the `updateMatchByNodeId` mutation."""
input UpdateMatchByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Match` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Match` being updated.
  """
  patch: MatchPatch!
}

"""
Represents an update to a `Match`. Fields that are set will be updated.
"""
input MatchPatch {
  """Location where the match is held."""
  location: String

  """Start and end time of the match."""
  time: DatetimeRangeInput

  """Minimun and maximun number of players in the match."""
  playerLimit: IntRangeInput

  """Is the match public or private. Default is private."""
  public: Boolean

  """List of participant names who have joined the match."""
  participants: [String]
}

"""All input for the `updateMatch` mutation."""
input UpdateMatchInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Match` being updated.
  """
  patch: MatchPatch!

  """Unique id of the match."""
  id: Int!
}

"""The output of our delete `Match` mutation."""
type DeleteMatchPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Match` that was deleted by this mutation."""
  match: Match
  deletedMatchNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Match`."""
  host: User

  """An edge for our `Match`. May be used by Relay 1."""
  matchEdge(
    """The method to use when ordering `Match`."""
    orderBy: [MatchesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MatchesEdge
}

"""All input for the `deleteMatchByNodeId` mutation."""
input DeleteMatchByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Match` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMatch` mutation."""
input DeleteMatchInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """Unique id of the match."""
  id: Int!
}

"""The output of our `upsertUser` mutation."""
type UpsertUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `upsertUser` mutation."""
input UpsertUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}
